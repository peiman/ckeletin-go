// scripts/generate-config-constants.go
//
// Code generator that creates type-safe constants for all configuration keys.
// This prevents typos and provides compile-time safety when referencing config keys.
//
// Usage: go run scripts/generate-config-constants.go

//go:build ignore

package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/peiman/ckeletin-go/.ckeletin/pkg/config"
	_ "github.com/peiman/ckeletin-go/.ckeletin/pkg/config/commands" // Import to trigger init() functions (framework)
	_ "github.com/peiman/ckeletin-go/internal/config/commands"      // Import to trigger init() functions (project)
)

const fileHeader = `// Code generated by scripts/generate-config-constants.go. DO NOT EDIT.

package config

// Configuration key constants - automatically generated from registry
// These constants provide compile-time safety when referencing config keys
const (
{{- range .Options}}
	{{.ConstName}} = "{{.Key}}"{{if .Description}} // {{.Description}}{{end}}
{{- end}}
)
`

type OptionData struct {
	Key         string
	ConstName   string
	Description string
}

func main() {
	options := config.Registry()

	var data []OptionData
	seen := make(map[string]bool)

	for _, opt := range options {
		// Convert "app.ping.output_message" to "KeyAppPingOutputMessage"
		constName := toConstName(opt.Key)

		// Skip duplicates (shouldn't happen, but be safe)
		if seen[constName] {
			fmt.Fprintf(os.Stderr, "Warning: Duplicate constant name %s for key %s\n", constName, opt.Key)
			continue
		}
		seen[constName] = true

		// Truncate long descriptions
		desc := opt.Description
		if len(desc) > 80 {
			desc = desc[:77] + "..."
		}

		data = append(data, OptionData{
			Key:         opt.Key,
			ConstName:   constName,
			Description: desc,
		})
	}

	// Parse template
	tmpl, err := template.New("constants").Parse(fileHeader)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse template: %v\n", err)
		os.Exit(1)
	}

	// Create output file
	// Check for framework structure first, fall back to old path for backwards compatibility
	outFile := ".ckeletin/pkg/config/keys_generated.go"
	if _, err := os.Stat(".ckeletin/pkg/config"); os.IsNotExist(err) {
		outFile = "internal/config/keys_generated.go"
	}
	f, err := os.Create(outFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	// Execute template
	if err := tmpl.Execute(f, map[string]interface{}{
		"Options": data,
	}); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to execute template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("âœ… Generated %d config key constants in %s\n", len(data), outFile)
	fmt.Println("ðŸ“ Run 'task format' to format the generated file")
}

// toConstName converts a config key to a constant name
// Example: "app.ping.output_message" -> "KeyAppPingOutputMessage"
func toConstName(key string) string {
	parts := strings.Split(key, ".")
	var result strings.Builder
	result.WriteString("Key")

	for _, part := range parts {
		// Convert snake_case to PascalCase
		words := strings.Split(part, "_")
		for _, word := range words {
			if word == "" {
				continue
			}
			// Capitalize first letter, lowercase rest
			result.WriteString(strings.ToUpper(word[:1]))
			if len(word) > 1 {
				result.WriteString(strings.ToLower(word[1:]))
			}
		}
	}

	return result.String()
}
