# Taskfile.yml
version: '3'

vars:
  BINARY_NAME: ckeletin-go
  MODULE_PATH: github.com/peiman/ckeletin-go
  VERSION:
    sh: git describe --tags --always --dirty
  COMMIT:
    sh: git rev-parse HEAD
  DATE:
    sh: date -u '+%Y-%m-%d_%H:%M:%S'
  LDFLAGS: >-
    -ldflags="
    -X '{{.MODULE_PATH}}/cmd.binaryName={{.BINARY_NAME}}'
    -X '{{.MODULE_PATH}}/cmd.Version={{.VERSION}}'
    -X '{{.MODULE_PATH}}/cmd.Commit={{.COMMIT}}'
    -X '{{.MODULE_PATH}}/cmd.Date={{.DATE}}'
    "

tasks:
  default:
    cmds:
      - task --list
    silent: true

  setup:
    desc: Install development tools
    cmds:
    - go install golang.org/x/tools/cmd/goimports@latest
    - go install golang.org/x/vuln/cmd/govulncheck@latest
    - go install gotest.tools/gotestsum@latest
    - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
    - go install github.com/evilmartians/lefthook@latest
    - go install github.com/psampaz/go-mod-outdated@latest
    - lefthook install
    silent: true

  tidy:
    desc: Ensure go.mod and go.sum are up to date
    cmds:
      - go mod tidy

  deps:verify:
    desc: Verify that dependencies haven't been modified
    cmds:
      - go mod verify
    silent: true

  deps:outdated:
    desc: Check for outdated dependencies
    cmds:
      - echo "Checking for outdated dependencies..."
      - go list -u -m -json all | go-mod-outdated -update -direct
    silent: true

  deps:check:
    desc: Run all dependency checks
    cmds:
      - task: deps:verify
      - task: deps:outdated
      - task: vuln
    silent: true

  format:
    desc: Format all Go code
    cmds:
      - ./scripts/format-go.sh fix

  format:check:
    desc: Check if Go code is formatted (CI mode)
    cmds:
      - ./scripts/format-go.sh check

  lint:
    desc: Run all linters
    cmds:
      - go vet ./...
      - golangci-lint run

  vuln:
    desc: Check for vulnerabilities
    cmds:
      - govulncheck ./...

  check-defaults:
    desc: Check for unauthorized viper.SetDefault() calls
    cmds:
      - ./scripts/check-defaults.sh
    silent: false

  validate-commands:
    desc: Validate command files follow ultra-thin patterns
    cmds:
      - ./scripts/validate-command-patterns.sh
    silent: false

  test:
    desc: Run tests with coverage
    cmd: |
      gotestsum --format pkgname --jsonfile test-output.json --hide-summary=skipped -- -v -coverprofile=coverage.txt -covermode=atomic ./...

  test:race:
    desc: Run tests with race detection
    cmd: |
      gotestsum --format standard-verbose --jsonfile test-output.json -- -v -race ./...

  test:watch:
    desc: Run tests in watch mode
    cmd: |
      gotestsum --format pkgname --watch --hide-summary=skipped

  test:coverage-text:
    desc: Run tests with detailed coverage data and display uncovered parts in the terminal
    cmds:
      - gotestsum --format pkgname --jsonfile test-output.json --hide-summary=skipped -- -cover -coverprofile=coverage.txt -covermode=atomic ./...
      - echo "Detailed coverage report:"
      - go tool cover -func=coverage.txt
    silent: false

  test:coverage-html:
    desc: Generate HTML coverage report and open in browser
    cmds:
      - task: test
      - go tool cover -html=coverage.txt -o coverage.html
      - echo "Coverage report saved to coverage.html"
      - '{{if eq OS "darwin"}}open{{else if eq OS "windows"}}start{{else}}xdg-open{{end}} coverage.html'
    silent: true

  bench:
    desc: Run all benchmarks
    cmd: |
      go test -bench=. -benchmem ./... -run=^$ | tee bench-results.txt
      echo "Benchmark results saved to bench-results.txt"
    silent: false

  bench:cmd:
    desc: Run benchmarks for cmd package
    cmd: |
      go test -bench=. -benchmem ./cmd -run=^$

  bench:config:
    desc: Run benchmarks for config package
    cmd: |
      go test -bench=. -benchmem ./internal/config -run=^$

  bench:logger:
    desc: Run benchmarks for logger package
    cmd: |
      go test -bench=. -benchmem ./internal/logger -run=^$

  bench:compare:
    desc: Compare benchmark results (requires benchstat)
    cmds:
      - |
        if [ ! -f bench-old.txt ]; then
          echo "No baseline found. Run 'task bench' first and copy bench-results.txt to bench-old.txt"
          exit 1
        fi
      - task: bench
      - cp bench-results.txt bench-new.txt
      - benchstat bench-old.txt bench-new.txt

  docs:config:
    desc: Generate configuration documentation
    cmds:
      - echo "Generating configuration documentation..."
      - mkdir -p docs
      - ./{{.BINARY_NAME}} docs config --output=docs/configuration.md
      - echo "Configuration documentation saved to docs/configuration.md"
    deps: [build]

  docs:config-yaml:
    desc: Generate YAML configuration template
    cmds:
      - echo "Generating YAML configuration template..."
      - mkdir -p docs
      - ./{{.BINARY_NAME}} docs config --format=yaml --output=docs/config-template.yaml
      - echo "YAML template saved to docs/config-template.yaml"
    deps: [build]

  docs:
    desc: Generate all documentation
    cmds:
      - task: docs:config
      - task: docs:config-yaml
    silent: true

  check:
    desc: Run all quality checks
    cmds:
      - task: format:check
      - task: lint
      - task: check-defaults
      - task: validate-commands
      - task: deps:check
      - task: test

  build:
    desc: Build the binary
    cmds:
      - go build {{.LDFLAGS}} -o {{.BINARY_NAME}} main.go

  run:
    desc: Run the application
    deps: [build]
    cmds:
      - ./{{.BINARY_NAME}}

  install:
    desc: Install the application
    cmds:
      - go install {{.LDFLAGS}} ./...

  clean:
    desc: Clean build artifacts
    cmds:
      - go clean
      - rm -f {{.BINARY_NAME}} coverage.txt test-output.json coverage.html
      - rm -rf ./dist

  generate:constants:
    desc: Generate type-safe config key constants
    cmds:
      - go run scripts/generate-config-constants.go
      - task: format

  generate:command:
    desc: Scaffold a new ultra-thin command with metadata and options
    vars:
      NAME: "{{.name}}"
      CMD_FILE: "cmd/{{.NAME}}.go"
      CFG_FILE: "internal/config/commands/{{.NAME}}_config.go"
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task generate:command name=<command_name>" >&2; exit 1; fi
      - |
        cp cmd/template_command.go.example {{.CMD_FILE}} && \
        sed -i '' "s/template/{{.NAME}}/g" {{.CMD_FILE}} && \
        sed -i '' "s/Template/{{.NAME | title}}/g" {{.CMD_FILE}}
      - |
        cp internal/config/commands/template_config.go.example {{.CFG_FILE}} && \
        sed -i '' "s/template/{{.NAME}}/g" {{.CFG_FILE}} && \
        sed -i '' "s/Template/{{.NAME | title}}/g" {{.CFG_FILE}}
      - echo "✅ Scaffolded ultra-thin command"
      - echo "   Command {{.CMD_FILE}}"
      - echo "   Config {{.CFG_FILE}}"
      - echo ""
      - echo "Next steps"
      - echo "1. Create business logic in internal/{{.NAME}}/"
      - echo "2. Update metadata and options in {{.CFG_FILE}}"
      - echo "3. Update runTemplate function in {{.CMD_FILE}}"
      - echo "4. Run task validate-commands to verify pattern"

  release:check:
    desc: Check if GoReleaser is installed
    cmds:
      - |
        if ! command -v goreleaser &> /dev/null; then
          echo "❌ GoReleaser is not installed."
          echo ""
          echo "Install GoReleaser:"
          echo "  macOS:   brew install goreleaser"
          echo "  Linux:   https://goreleaser.com/install/"
          echo "  Go:      go install github.com/goreleaser/goreleaser@latest"
          exit 1
        fi
        echo "✅ GoReleaser is installed: $(goreleaser --version)"
    silent: false

  release:test:
    desc: Test GoReleaser configuration (snapshot build, no release)
    deps: [release:check]
    cmds:
      - echo "Building snapshot release (no tags required)..."
      - goreleaser release --snapshot --clean --skip=publish
      - echo ""
      - echo "✅ Snapshot build successful!"
      - echo "Artifacts are in ./dist/"
      - echo ""
      - echo "To test the binaries (Linux, macOS, Windows)"
    silent: false

  release:build:
    desc: Build release artifacts locally (requires git tag)
    deps: [release:check]
    cmds:
      - echo "Building release artifacts..."
      - goreleaser build --clean --snapshot
      - echo ""
      - echo "✅ Build successful!"
      - echo "   Binaries are in ./dist/"

  release:clean:
    desc: Clean GoReleaser artifacts
    cmds:
      - rm -rf ./dist
      - echo "✅ Cleaned release artifacts"
