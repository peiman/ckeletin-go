# Taskfile.yml - Project tasks
# This file includes the ckeletin framework and adds project-specific tasks.
version: '3'

vars:
  # Project configuration - customize these for your CLI
  BINARY_NAME: ckeletin-go
  MODULE_PATH:
    sh: go list -m

includes:
  ckeletin:
    taskfile: .ckeletin/Taskfile.yml
    vars:
      BINARY_NAME: '{{.BINARY_NAME}}'
      MODULE_PATH: '{{.MODULE_PATH}}'

tasks:
  default:
    cmds:
      - task --list
    silent: true

  # === Convenience Aliases ===
  # These let you run `task check` instead of `task ckeletin:check`

  setup:
    desc: Install development tools
    cmds: [task: ckeletin:setup]

  doctor:
    desc: Check development environment
    cmds: [task: ckeletin:doctor]

  format:
    desc: Format all Go code
    cmds: [task: ckeletin:format]

  lint:
    desc: Run all linters
    cmds: [task: ckeletin:lint]

  test:
    desc: Run tests with coverage
    cmds: [task: ckeletin:test]

  build:
    desc: Build the binary
    cmds: [task: ckeletin:build]

  check:
    desc: Run all quality checks
    cmds: [task: ckeletin:check]

  check:fast:
    desc: Run fast quality checks
    cmds: [task: ckeletin:check:fast]

  clean:
    desc: Clean all artifacts
    cmds: [task: ckeletin:clean]

  # === Hook Aliases (used by .lefthook.yml) ===

  format:staged:
    cmds: [task: ckeletin:format:staged]

  validate:constants:
    cmds: [task: ckeletin:validate:constants]

  check:deps:verify:
    cmds: [task: ckeletin:check:deps:verify]

  check:secrets:staged:
    cmds: [task: ckeletin:check:secrets:staged]

  check:vuln:fast:
    cmds: [task: ckeletin:check:vuln:fast]

  test:coverage:
    cmds: [task: ckeletin:test:coverage]

  # === Framework Update ===

  ckeletin:update:
    desc: Update ckeletin framework to latest version
    cmds:
      - |
        echo "ðŸ”„ Updating ckeletin framework..."
        if git remote | grep -q ckeletin-upstream; then
          echo "   Remote 'ckeletin-upstream' already exists"
        else
          echo "   Adding remote 'ckeletin-upstream'..."
          git remote add ckeletin-upstream https://github.com/peiman/ckeletin-go.git
        fi
        echo "   Pulling latest framework..."
        git subtree pull --prefix=.ckeletin ckeletin-upstream main --squash -m "chore: update ckeletin framework"
        echo ""
        echo "âœ… Framework updated successfully!"
        echo "   Review changes with: git diff HEAD~1"

  # === Project-Specific Tasks ===

  init:
    desc: Initialize scaffold with custom name and module
    summary: |
      Automates scaffold customization by updating module path and binary name
      throughout the codebase. This is the first command you run after cloning.

      Usage:
        task init name=<name> module=<module>

      Example:
        task init name=myapp module=github.com/myuser/myapp
    vars:
      NAME: "{{.name}}"
      MODULE: "{{.module}}"
      OLD_MODULE: "github.com/peiman/ckeletin-go"
      OLD_NAME: "ckeletin-go"
    preconditions:
      - sh: '[ -n "{{.NAME}}" ]'
        msg: "Binary name is required. Usage: task init name=<name> module=<module>"
      - sh: '[ -n "{{.MODULE}}" ]'
        msg: "Module path is required. Usage: task init name=<name> module=<module>"
      - sh: '[ "{{.MODULE}}" != "{{.OLD_MODULE}}" ]'
        msg: "Module path must be different from {{.OLD_MODULE}}"
    cmds:
      - echo "ðŸš€ Initializing scaffold..."
      - go run .ckeletin/scripts/scaffold-init.go "{{.OLD_MODULE}}" "{{.MODULE}}" "{{.OLD_NAME}}" "{{.NAME}}"
      - go mod tidy
      - echo ""
      - echo "âœ… Scaffold initialized successfully!"
      - echo "   Binary{{":"}} {{.NAME}}"
      - echo "   Module{{":"}} {{.MODULE}}"
      - echo ""
      - echo "Next steps{{":"}}"
      - echo "  1. Format code{{":"}} task format"
      - echo "  2. Review changes{{":"}} git diff"
      - echo "  3. Run quality checks{{":"}} task check"
      - echo "  4. Build binary{{":"}} task build"
      - echo "  5. Test binary{{":"}} ./{{.NAME}} --version"

  generate:command:
    desc: Scaffold a new ultra-thin command with metadata and options
    vars:
      NAME: "{{.name}}"
      CMD_FILE: "cmd/{{.NAME}}.go"
      CFG_FILE: "internal/config/commands/{{.NAME}}_config.go"
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task generate:command name=<command_name>" >&2; exit 1; fi
      - |
        cp cmd/template_command.go.example {{.CMD_FILE}} && \
        sed -i '' "s/template/{{.NAME}}/g" {{.CMD_FILE}} && \
        sed -i '' "s/Template/{{.NAME | title}}/g" {{.CMD_FILE}}
      - |
        cp internal/config/commands/template_config.go.example {{.CFG_FILE}} && \
        sed -i '' "s/template/{{.NAME}}/g" {{.CFG_FILE}} && \
        sed -i '' "s/Template/{{.NAME | title}}/g" {{.CFG_FILE}}
      - echo "âœ… Scaffolded ultra-thin command"
      - echo "   Command {{.CMD_FILE}}"
      - echo "   Config {{.CFG_FILE}}"
      - echo ""
      - echo "Next steps"
      - echo "1. Create business logic in internal/{{.NAME}}/"
      - echo "2. Update metadata and options in {{.CFG_FILE}}"
      - echo "3. Update runTemplate function in {{.CMD_FILE}}"
      - echo "4. Run task ckeletin:validate:commands to verify pattern"

  generate:docs:config:
    desc: Generate configuration documentation
    cmds:
      - echo "Generating configuration documentation..."
      - mkdir -p docs
      - ./{{.BINARY_NAME}} docs config --output=docs/configuration.md
      - echo "Configuration documentation saved to docs/configuration.md"
    deps: [build]

  generate:config:template:
    desc: Generate YAML configuration template
    cmds:
      - echo "Generating YAML configuration template..."
      - mkdir -p docs
      - ./{{.BINARY_NAME}} docs config --format=yaml --output=docs/config-template.yaml
      - echo "YAML template saved to docs/config-template.yaml"
    deps: [build]

  generate:docs:
    desc: Generate all documentation
    cmds:
      - task: generate:docs:config
      - task: generate:config:template
    silent: true
